<h2>Atividade: escreva um comentário sobre o texto abaixo:</h2>
"We see three critical differences between programming and software engineering: time, scale, and the trade-offs at play. On a software engineering project, engineers need to be more concerned with the passage of time and the eventual need for change. In a software engineering organization, we need to be more concerned about scale and efficiency, both for the software we produce as well as for the organization that is producing it. Finally, as software engineers, we are asked to make more complex decisions with higher-stakes outcomes, often based on imprecise estimates of time and growth. Within Google, we sometimes say, “Software engineering is programming integrated over time.” Programming is certainly a significant part of software engineering: after all, programming is how you generate new software in the first place. If you accept this distinction, it also becomes clear that we might need to delineate between programming tasks (development) and software engineering tasks (development, modification, maintenance). The addition of time adds an important new dimension to programming. Cubes aren’t squares, distance isn’t velocity. Software engineering isn’t programming."

Titus Winters, Software Engineering at Google

<h3>Comentário:</h3>
O texto nos ajuda a compreender a diferença entre a engenharia de software e a programação, que frequentemente são confundidas e/ou comparadas por muitos. No geral, a programação trata-se de se especializar em um programa específico e utilizá-lo para a solução de problemas, e a engenharia de software trata-se do conhecimento aprofundado sobre a estrutura de um programa.
Isso nos levanta uma questão importante, muito discutida nos dias atuais, sobre as diferenças entre a variedade de softwares existentes. Um engenheiro de software deve ter uma visão ampla e saber eliminar dívidas técnicas entre programas, tendo a clara ideia de que não existe nenhum software que seja superior à outro, já que o grau de utilidade de uma ferramenta varia de acordo com o problema em que ela será aplicada. Por isso, o engenheiro de software deve realizar uma análise crítica sobre o programa a ser utilizado, e sobre as outras possíveis opções, para que a melhor escolha seja feita de acordo com as exigências do problema, utilizando uma tecnologia que melhor se adapte a ele.

<br>
<hr>

<h2>O que é um trade-off na escolha das ferramentas utilizadas no API?</h2> 
Trade-off trata-se de um termo utilizado para definir a decisão que um indivíduo deve tomar ao escolher uma opção, deixando uma outra de lado. Essa decisão se dá através da análise das opções, sejam elas ferramentas ou aplicações, onde necessidades são colocadas em discussão para que um consenso seja alcançado pelo usuário, definindo qual opção traz mais vantagens em cada situação. No geral, durante essas discussões são priorizadas a acessibilidade, disponibilidade, usabilidade, custos e eficiência de uma opção quando comparada à outra em determinada aplicação. <br>
Sendo assim, podemos aplicar essa estratégia durante o desenvolvimento do Projeto Integrador, uma vez que, dentro da área de TI, há uma infinidade de ferramentas que podem ser utilizadas para a execução do projeto em questão. Para isso, é levado em consideração o que leva uma ferramenta ser mais favorável ao uso do que outra, de acordo com a necessidade do desenvolvedor. Toda tecnologia tem seus pontos positivos e negativos, e esses podem variar de acordo com a aplicação em que será utilizada, logo, uma tecnologia pode ter mais utilidade em uma área do que outra, bastando ao usuário realizar a análise do que pode ser mais vantajoso para tal exigência.

<br>
<hr>

<h2>Atividade de Requisitos</h2>
<h3>Sistema de Controle de Acesso com Sensor Biométrico</h3>
<b>Funcionais:</b>
<ul>
  <li> O usuário pode cadastrar sua digital no sistema através do sensor;
  <li> O usuário insere sua digital no sensor biométrico;
  <li> O sistema confere se a digital está cadastrada;
  <li> Se a digital estiver cadastrada, o usuário insere o número da porta que deseja abrir;
  <li> Se o usuário tiver acesso, a porta é aberta;
</ul>
<br>
<b>Não-funcionais:</b>
<ul>
  <li> Possibilidade de cadastrar novas digitais no sistema;
  <li> Armazenamento de digitais;
  <li> Relacionamento entre salas e nível de acesso de cada usuário à elas;
</ul>

<h3>Diagrama de Casos de Uso</h3>
<img src="" alt="Diagrama de Casos de Uso">

<br>

<h3>Diagrama de Classe UML</h3>
<img src="https://github.com/JoaoGRMira/bertoti/blob/main/Engenharia%20de%20Software%20I/Diagrama%20de%20Classe%20UML%20-%20Sistema%20de%20Controle.png">

<br>

<h3>Código (Java)</h3>

