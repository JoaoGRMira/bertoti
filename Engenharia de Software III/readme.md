Nome do Padrão | Anti-Padrão | Defiinição do Padrão | Problema que ele resolve
:---: | :---: | :---: | :---: |
Strategy | Repetição de código; Número limitado de estratégias; Complexidade desnecessária na configuração; Excesso de abstração; Pequenas variações no comportamento entre as estratégias; Uso de Strategy Pattern em cenários simples | É um padrão de projeto de software comportamental que pertence à categoria dos padrões de design | Permite que o cliente escolha o algoritmo a ser usado a partir de um conjunto de algoritmos diferentes durante a execução de um programa, sem que o cliente precise conhecer os detalhes de implementação dos algoritmos
Observer | Sujeito notifica o Observer com muita frequência; Dependência na ordem de notificação; Vazamento de memória de observadores quando eles não são adequadamente removidos do sujeito; Observadores realizando lógicas muito complexas; Interfaces de observador excessivamente complexas; Acoplamento excessivo; Consulta ineficiente; Uso excessivo de observadores para recursos não essenciais | É um padrão de design comportamental usado em programação para definir uma relação de um-para-muitos entre objetos | Permite que um objeto, chamado de "sujeito" ou "publicador", notifique uma lista de objetos dependentes, chamados "observadores", quando seu estado interno muda, sem que os observadores conheçam detalhes do sujeito
Composite | Complexidade excessiva da interface componente; Uso excessivo do composite pattern; Desempenho ineficiente; Manipulação excessiva do componente raiz; Hierarquias excessivamente profundas; Falta de cuidado com a atualização de estados compartilhados; Falta de design claro da interface componente | É um padrão de design estrutural que permite que você componha objetos em estruturas de árvore para representar hierarquias de partes todo | É usado para tratar objetos individuais e composições de objetos de maneira uniforme
